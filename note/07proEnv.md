# 07进程环境

* **main函数**
```
int main(int argc, char* argv[])
{
	return 0;
}
```
argc：表示命令行的参数个数
argv：表示指向各参数的指针数组

* **进程正常终止方式（非正常以后再说）**
1）从main函数返回
2）调用库函数exit()
3）调用系统调用 _exit()
一个一个说：
**main函数返回**：编程语言级别的操作，一般由return返回，也可以由exit()来操作，因为main()函数结束会自动调用exit()
**库函数exit()**：库函数调用，先执行atexit()函数注册的终止处理程序，再进行IO库的清理和关闭操作，使得缓存区的数据都被写到相应文件中，然后最后调用_exit()系统调用返回内核
**系统调用_exit()**：系统调用，直接返回内核，并不清理缓存区

* **return与exit的区别**
return：是语言级别的操作，返回函数值，将控制权交给调用函数，表示的是调用堆栈的返回
exit：是库函数，是系统调用级别的操作，它表示一个进程的终止，把控制权交给操作系统
main函数终止时，会隐式调用exit函数，刷新缓存区，进程终止，返回内核

* **exit与_exit的区别**
exit：是C库函数，会先执行atexit函数注册过的进程终止程序，再刷新缓存区，然后调用_exit返回内核
_exit：是系统调用，直接终止进程，返回内核

* **C程序存续空间布局**
从低地址到高地址：
**代码段**：CPU要执行的指令，一般只有一个副本，可共享，只可读
**初始化数据段**：已初始化的全局变量与静态变量
**未初始化数据段BBS**：未初始化的全局变量与静态变量，在程序执行之前自动清零，所以未初始化的全局变量与静态变量都是0
**堆**：动态内存分配的区域
**栈**：自动变量以及每次函数调用所需要的信息
```

|---------------------| 高地址
		   栈
|---------------------|		 
		   ..
		   ..
|---------------------|
		   堆
|---------------------|
      未初始化全局变量
|---------------------|
       初始化全局变量
|---------------------|
          代码段
|---------------------| 低地址

```
堆顶到栈顶之间的虚拟空间很大
需要存在磁盘程序文件的只有代码段与初始化变量段

* **共享库，动态链接**
共享库使得一个程序文件不再需要包含公有的库函数
把公共库放在一个所有进程都可以引用的存储空间
程序第一次调用库函数时，动态链接到库函数区域
优点：
1）可执行文件的正文段与初始化数据段的长度将显著减小
2）库函数版本更新时，引用库函数的程序不需要重新编译
缺点：
1）会增加一定的时间开销

* **存储空间的分配**：malloc，calloc，realloc

```
#include <stdlib.h>
void* malloc(size_t size);
void* calloc(size_t nobj, size_t size);
void* realloc(void* ptr, size_t size)
都返回指向新分配空间的首地址的空指针
```
malloc：分配size个字节的空间，但是不初始化
calloc：分配nobj个size大小的空间，即总nobj×size大小，并全部初始化为0
realloc：ptr是原地址，size是要分配的新地址，realloc新寻找一块大于size的连续新区域分配内存，并返回指向首地址的指针，并且会回收原地址的内存

* **关于内存分配的一些问题，重要！！！**
1）**大部分实现所分配的内存会比要求的大一些**，因为需要额外的信息来记录管理信息：比如分配块的长度，指向下一个分配块的指针等
2）如果**指针越界进行写操作**，就可能会把一些管理信息，或者其他不相关动态分配的对象进行改写，这样的错误是灾难性的，而且很难被发现
3）如果**多次释放一个已释放的区域**，也会造成严重后果。因为free之后内存就被操作系统收回了，此时系统可能把这块区域分配给其他对象了，而再次free释放的话，就把其他动态对象的内存给释放了。一般编译器会报错。最佳实践：free一个指针后，立即把该指针置为0
4）如果**动态分配的内存没有被回收，内存泄露**。该进程的堆空间会不断增加，进程空间不断增加，由于过度的换页开销，系统性能降低，
***PS**：过度的换页开销，如果系统此时进程很少。*
*1）而进程A空间一直增加，那么系统就会分配给进程A很多的空间，越来越多，如果此时有其他进程BCD..开始执行，也需要分配空间，那么就需要把进程A的空间减少一些，就需要把进程A的页面从内存中换出很多，造成颠簸*
*2）进程A中很多分配了却没有释放而且不用了的内存，这些动态内存也需要页面置换的消耗*
*3）当进程A进程变大时，相应的给它的实际页框数也会增加，其他进程的页框数也就减少了，而进程A很多内存都是没有用的，空占内存*

* **setjmp，longjmp**
goto可以在函数内随时回到一个lable，但是不能跨越函数
setjmp和longjmp提供了一种跨越函数的做法
在函数调用栈比较深时，若调用较深的函数出错，则需一层一层返回信息
而longjmp可以跳过中间的栈，直接找到setjmp的位置返回
setjmp：标记希望返回的位置，可以有多个，相当于lable
longjmp：返回指定的setjmp的位置，可选择回到哪一个

