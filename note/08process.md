# 08process
* **进程标识符pid**：每个进程具有唯一的标识符

```
pid_t getpid();	//返回本进程的pid
pid_t getppid();    //返回本进程的父进程的pid
```

* **fork**：一个进程可以创建一个新的进程

```
pid_t fork();
```
进程A调用fork后，系统创建子进程，子进程获得独立的进程空间
子进程获得父进程堆，栈，数据段的副本，与父进程共享代码段
注意：IO缓存的也会被拷贝，文件描述符以及偏移量会被父子进程共享
fork函数返回两次，对父进程返回子进程的pid，对子进程返回0
fork并无法预知父子进程谁先执行。。。

* **进程终止**
子进程调用exit(stat)传递退出状态给父进程
父进程调用wait/waitpid来取得子进程的终止状态。
如果父进程在子进程之前退出，则子进程的父进程变为init进程，pid为1，子进程也就变为了**孤儿进程**。
子进程终止时，内核会为其保存一些信息（进程id，进程终止状态，进程使用CPU时间等）
父进程可以调用wait/waitpid来获取这些信息
如果子进程终止了，父进程却没有调用wait/waitpid来获取子进程的终止信息
那么这些信息就会一直保存在内核中，占用内核空间，并且占用pid号，也就是**僵尸进程**
由于内核空间有限，内核所能使用的pid号也是有限的，如果产生了太多的僵尸进程，会导致系统不能产生新的进程

* **孤儿进程**
父进程在子进程之前终止，子进程就变成了孤儿进程，被init进程收养（pid为1）
当子进程也终止时，init进程会调用wait函数，释放子进程的终止信息
所以，孤儿进程没有危害

* **僵尸进程**
当子进程终止了，内核为其保留了一定的终止信息（pid号，终止信息，CPU运行时间）
但是父进程却没有调用wait/waitpid函数获取子进程的终止信息
导致子进程成为了僵尸进程，其在内核中的信息一直无法被释放
危害：因为系统能使用的pid号也是有限的，如果产生大量的僵尸进程，可能导致系统无法创建新的进程


* **wait/waitpid**
当子进程正常或异常终止时，会向其父进程发送SIGCHLD信号
父进程可以选择忽略该信号，或者提供处理程序
```
#include <sys/wait.h>
pid_t wait(int* statloc);
pid_t waitpid(pid_t pid, int* statloc, int options);
调用成功返回子进程pid，失败返回0或-1
```
参数：
statloc：表示获取子进程终止信息后，存放终止信息的地址，如果不存放，可以为空
pid：一般为要等待的pid号的子进程
options：比较复杂。。。

**调用wait/waitpid可能发生什么**
1）如果所有进程都还在运行，那么会阻塞
2）如果有一个子进程终止，则获取其终止信息，并立刻返回
3）如果不存在子进程，则调用出错，立即返回

**wait与waitpid的区别**
1）如果所有进程都还在运行，那么wait选择阻塞；waitpid可以选择不阻塞
2）如果有一个子进程终止，wait立即返回；waitpid可选择它所等待的子进程
3）waitpid增加了一些选项，可以支持作业控制

* **竞争条件**
如果多个进程对某一共享数据进行处理
而最后的处理结果与进程的执行顺序有关
那么就认为他们之间存在竞争条件
需要用互斥，信号量，条件变量等来处理

* **exec函数**
父进程通过fork函数创建子进程之后
如果子进程需要执行无父进程无关的程序
就可以exec函数把从父进程拷贝过来的进程地址空间的副本替换成需要执行的程序
exec一共有7个函数，各个函数参数不一样，比较难记

* **awk**：没太搞懂
awk是一个功能强大的文本处理工具

* **进程会计**
系统会提供进程会计的选项
用于记录各个进程占用CPU的时间，用户ID，组ID，启动时间等等。。。

* **进程调度**
操作系统提供nice函数可调整进程的优先级
nice值越大，越友好，优先级越低
nice值越小，越不友好，优先级越高
```
int nice(int incr);  // 进程当前nice值加上incr值为调整过后的nice值
```
